<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>能调用任意函数的函数</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    
  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="/">Home</a></li>
      
      <li><a href="/about/">About</a></li>
      
      <li><a href="/tags/">Tags</a></li>
      
      <li><a href="/index.xml">Subscribe</a></li>
      
    </ul>
    <hr/>
    </nav>

<div class="article-meta">
<h1><span class="title">能调用任意函数的函数</span></h1>

<h2 class="date">2018/01/26</h2>
</div>

<main>
<p>其实这是某社团第三次 C 语言作业中一道附加题，当时一看到题目就觉得很有趣，花了一个下午研究了函数调用栈，内嵌汇编的知识，当晚给做了出来。能跑，但是没有解决函数的返回类型这个问题。</p>

<p>这几天接触宏函数接触得比较多，尝试着实现了一个没用的伪泛型宏函数：</p>

<pre><code class="language-c">#define declare_function(type, function_name, ...) \
    type function_name ## _ ## type(__VA_ARGS__)

declare_function(int, my_f, int argc, char *argv[]) {
    return call(...);
}
</code></pre>

<p>上边这段代码会被展开成为：</p>

<pre><code class="language-c">int my_f_int(int argc, char *argv[]) {
    return call(...);
}
</code></pre>

<p>原本按照我的设想，通过临时定义一个函数就可以让用户指定返回类型了，虽然多次调用会使函数重名，但至少离目标更近了一步。但是等到 gcc 报错我才意识到，函数不能嵌套定义…</p>

<p>所以又停滞了好几天，直到我看到一个用 gcc 特性实现的 lambda 宏函数，这件事才终于得到解决。虽然并非标准 C，但在这过程中已经学到够多了，心满意足。</p>

<p>Talk is cheap, here is my code :)</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;

#define lambda(type, function_body) \
    ({ type fn function_body fn; })
// usage: lambda(int, (int a, int b) { return a+b; })(2, 3) == 5
// 涉及的第一个特性叫 Statement Expression [1]
// 由括号包裹起来的代码可以有自己的循环、分支甚至是局部变量
// 考虑到这里涉及的代码不止一行，所以用花括号包裹起来(这一项是标准 C)
// 最后一行代码将成为整个 Statement Expression 的值
// 展开得到：
// ({
//   int fn (int a, int b) { return a+b; }
//   fn;
// }) (2, 3);
// 首先在 Statement Expression 中定义了一个局部函数，然后返回这个函数并调用
// 涉及到第二个特性叫 Nested Functions，可以在函数内定义函数 [2]

#define call(type, f, ...)              \ // 变参宏，C99
    lambda(type, (void(*pf)(), ...) {   \ // 传递的参数无需做处理，告诉编译器需要变参支持即可
        int return_to;                  \ // 储存调用点下一行指令的地址
        __asm__ __volatile__ (          \ // 内嵌汇编
                                        \ // 此时栈已经被清空重设，需要恢复未调用时的状态
            &quot;movl %%ebp, %%esp;&quot;        \ // 恢复栈顶
            &quot;movl (%%esp), %%ebp;&quot;      \ // 恢复栈基
            &quot;movl 4(%%esp), %0;&quot;        \ // 保存回溯点
            &quot;movl %0, 8(%%esp);&quot;        \ // 回溯点往上挪，覆盖掉传进来的第一个参数(pf)
            &quot;addl $8, %%esp;&quot;           \ // 使栈顶所指符合stdcall约定
                                        \ // 栈状态已经伪装完毕，仿佛未曾来过此地
                                        \ // 覆盖掉了 pf 这个额外的参数，其他参数原样扔给被调用函数
            &quot;jmp *%1;&quot;                  \ // 正式跳到被调用函数
            : &quot;=&amp;r&quot; (return_to)         \
            : &quot;nr&quot; (*pf));              \
    })((void(*)()) f, __VA_ARGS__)

int sum(int x, int y) {
    return x+y;
}

int main() {
    printf(&quot;Returned: %d\n&quot;, call(int, sum, 1, 2));
}
</code></pre>

<p>P.S. 有个简单粗暴的完美解决方法：</p>

<pre><code class="language-c">#define call(function_name, ...) function_name(__VA_ARGS__)
</code></pre>

<p>不过看起来总觉得不够 Geek，是吧…</p>

<hr />

<p>Reference:</p>

<ol>
<li><a href="https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html">Statement Expression, GCC Manual</a></li>
<li><a href="https://gcc.gnu.org/onlinedocs/gcc/Nested-Functions.html">Nested Function, GCC Manual</a></li>
<li><a href="https://gcc.gnu.org/onlinedocs/gcc/Variadic-Macros.html#Variadic-Macros">Macros with a Variable Number of Arguments, GCC Manual</a></li>
</ol>

</main>


<div id="disqus_thread"></div>
<script type="text/javascript">

(function() {
  
  
  if (window.location.hostname == "localhost")
    return;

  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  var disqus_shortname = 'oyiadin';
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com/" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


  <footer>
  <script src="/js/math-code.js"></script>
<script async src="//mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script>



  
  <hr/>
  &copy; <a href="https://blog.b1n.top/">oyiadin</a> | <a href="https://github.com/oyiadin">Github</a> | <a href="https://twitter.com/oyiadin">Twitter</a>
  
  </footer>
  </body>
</html>

