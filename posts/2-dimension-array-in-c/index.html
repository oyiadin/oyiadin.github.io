<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>C 中二维数组之我的理解</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    
  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="/">Home</a></li>
      
      <li><a href="/about/">About</a></li>
      
      <li><a href="/tags/">Tags</a></li>
      
      <li><a href="/index.xml">Subscribe</a></li>
      
    </ul>
    <hr/>
    </nav>

<div class="article-meta">
<h1><span class="title">C 中二维数组之我的理解</span></h1>

<h2 class="date">2017/12/15</h2>
</div>

<main>
<pre><code class="language-c">#include &lt;stdio.h&gt;

//void f(double []);   // double[] 等价于 double*，但如果是多维数组，只能省略第一维
//void f(double **);   // double[][4] 不与 double** 等价，因为第二维度不可省略
void f(double [][4]);  // double(*)[4] 与 double[][4] 等价

int main() {
    double a[3][4];

    for (int i=0; i&lt;3; ++i) {
        for (int j=0; j&lt;4; ++j) {
            a[i][j] = i+j/10.0;
            printf(&quot;[%d, %d] =&gt; %.1lf\n&quot;, i, j, a[i][j]);
        }
    }

    // Output:
    // [0, 0] =&gt; 0.0
    // [0, 1] =&gt; 0.1
    // [0, 2] =&gt; 0.2
    // [0, 3] =&gt; 0.3
    // [1, 0] =&gt; 1.0
    // [1, 1] =&gt; 1.1
    // [1, 2] =&gt; 1.2
    // [1, 3] =&gt; 1.3
    // [2, 0] =&gt; 2.0
    // [2, 1] =&gt; 2.1
    // [2, 2] =&gt; 2.2
    // [2, 3] =&gt; 2.3

    f(a);
}


void f(double (*a)[4]) {
    // a 是一个指针，指向的数据类型为“double [4]”

    printf(&quot;%d %d %d\n%d %d %d\n&quot;, sizeof(a), sizeof(a[0]), sizeof(a[0][0]),
        // 指针(一般)为 int，所以 4
        // 将 a 视作数组，取得第一个元素（类型为 double [4]），
        // 所以 sizeof(double)*4 = 32
        // a[0] 取得类型为 double [4] 的元素，对这个元素再次取下标，得到 double
        sizeof(double), sizeof(double*), sizeof(double**));

    // Output:
    // 8 32 8
    // 8 8 8
    
    // 阅读下文时，时刻记得，在内存中，这段数组不会额外储存任何指针
    // 真实情况是只有 3*4 个 double 型的数据紧密排列

    for (int i=0; i&lt;12; ++i)
        printf(&quot;[%4d] =&gt; %.1lf\n&quot;, i,    ( *a       ) [i]             );
        // *a 得到 double [4]，取下标可得 double，
        // 此例说明二维数组数据也是紧凑地并排放置

        // Output:
        // [   0] =&gt; 0.0
        // [   1] =&gt; 0.1
        // [   2] =&gt; 0.2
        // [   3] =&gt; 0.3
        // [   4] =&gt; 1.0
        // [   5] =&gt; 1.1
        // [   6] =&gt; 1.2
        // [   7] =&gt; 1.3
        // [   8] =&gt; 2.0
        // [   9] =&gt; 2.1
        // [  10] =&gt; 2.2
        // [  11] =&gt; 2.3

    for (int i=0; i&lt;8; ++i)
        printf(&quot;[%4d] =&gt; %.1lf\n&quot;, i,    ( *(a + 1) ) [i]             );
        // a+1 (类型依旧是指向 double[4] 的指针）指向将 a 视为数组的下一个元素，
        // 即跳过了第一个 double[4]
        // 然后解引用得到第二个 double[4]，再取下标，得到第二行开始的各个 double

        // Output:
        // [   0] =&gt; 1.0
        // [   1] =&gt; 1.1
        // [   2] =&gt; 1.2
        // [   3] =&gt; 1.3
        // [   4] =&gt; 2.0
        // [   5] =&gt; 2.1
        // [   6] =&gt; 2.2
        // [   7] =&gt; 2.3

    for (int i=0; i&lt;8; ++i)
        printf(&quot;[%4d] =&gt; %.1lf\n&quot;, i,    ( (double *) a   + 1 ) [i]   );
        // 先让 a 的类型从 double(*)[4] 变为 double(*)
        // 通过强制转换，我们故意让类型系统丢失了 a 的二维维度这个信息
        // 现在可以看成：a 是一个指针，但指向的数据类型不再是“double [4]”
        // 而是“double”（丢了维度信息）
        // 现在，double* 型的 a+1 不再是指向下一个 double[4]，
        // 而是指向往后跳过一个 double 的内存处
        // 接着，将 a+1 这个指针视作数组，取下标得到 double
        // 可以发现，这一次跳过的不是一行，而是一个元素(一个 double)
        
        // Output:
        // [   0] =&gt; 0.1
        // [   1] =&gt; 0.2
        // [   2] =&gt; 0.3
        // [   3] =&gt; 1.0
        // [   4] =&gt; 1.1
        // [   5] =&gt; 1.2
        // [   6] =&gt; 1.3
        // [   7] =&gt; 2.0

    // 综上，通过实验可得到以下结论：
    // 1. 二维数组在内存里依旧是线性储存，前行尾与后行首是完全紧挨着的
    // 2. 在传递参数的过程中，因为编译器会自动解开第一层数组，转换成指针
    //    本来就已经丢失第一维的长度了，所以函数原型可忽略第一维度
    //    但不可忽略后续维度
    // 3. 对于编译器，指针指向的类型十分重要
    //    知道了指针指向什么数据才可以对其进行 +1、解引用等操作
    // 4. 二维数组本质依旧是一维数组，只是指向的数据是另外的数组
    //    二维数组的第二层维度一旦被强制去除，将表现出与一维数组类似的行为

}
</code></pre>

</main>


<div id="disqus_thread"></div>
<script type="text/javascript">

(function() {
  
  
  if (window.location.hostname == "localhost")
    return;

  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  var disqus_shortname = 'oyiadin';
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com/" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


  <footer>
  <script src="/js/math-code.js"></script>
<script async src="//mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script>



  
  <hr/>
  &copy; <a href="https://blog.b1n.top/">oyiadin</a> | <a href="https://github.com/oyiadin">Github</a> | <a href="https://twitter.com/oyiadin">Twitter</a>
  
  </footer>
  </body>
</html>

