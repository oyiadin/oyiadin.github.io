<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>南邮网络攻防训练平台逆向入门题目 Writeup</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    
  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="/">Home</a></li>
      
      <li><a href="/about/">About</a></li>
      
      <li><a href="/tags/">Tags</a></li>
      
      <li><a href="/index.xml">Subscribe</a></li>
      
    </ul>
    <hr/>
    </nav>

<div class="article-meta">
<h1><span class="title">南邮网络攻防训练平台逆向入门题目 Writeup</span></h1>

<h2 class="date">2018/02/04</h2>
</div>

<main>


<p>共三道题，前边几道题比较简单，就不写 writeup 了。</p>

<h2 id="wxyvm">WxyVM</h2>

<p>二话不说拖进 IDA，找到 main() 后 F5，顺便给作用明显的变量命个名：</p>

<pre><code class="language-c">__int64 __fastcall main(__int64 a1, char **a2, char **a3)
{
  char v4; // [sp+Bh] [bp-5h]@1
  signed int i; // [sp+Ch] [bp-4h]@3

  puts(&quot;[WxyVM 0.0.1]&quot;);
  puts(&quot;input your flag:&quot;);
  scanf(&quot;%s&quot;, &amp;scanf_buffer_bytes);
  v4 = 1;
  sub_4005B6();
  if ( strlen(&amp;scanf_buffer_bytes) != 24 )
    v4 = 0;
  for ( i = 0; i &lt;= 23; ++i )
  {
    if ( *(&amp;scanf_buffer_bytes + i) != goal_dword[i] )
      v4 = 0;
  }
  if ( v4 )
    puts(&quot;correct&quot;);
  else
    puts(&quot;wrong&quot;);
  return 0LL;
}
</code></pre>

<p>代码逻辑很清晰，先读字符串到 <code>scanf_buffer_bytes</code>，然后调用 <code>sub_4005B6()</code>，推测是进行加密，子函数跑完后，让加密后的数据跟 <code>goal_dword</code> 进行比对。读懂代码后直接跟进去子函数，同样，先对意图明显的变量进行命名：</p>

<pre><code class="language-c">__int64 func()
{
  unsigned int v0; // ST04_4@3
  __int64 result; // rax@3
  signed int i; // [sp+0h] [bp-10h]@1
  char v3; // [sp+8h] [bp-8h]@3

  for ( i = 0; i &lt;= 14999; i += 3 )
  {
    v0 = raw_data[(signed __int64)i];
    v3 = raw_data[(signed __int64)(i + 2)];
    result = v0;
    switch ( v0 )
    {
      case 1u:
        result = raw_data[(signed __int64)(i + 1)];
        *(&amp;scanf_buffer_bytes + result) += v3;
        break;
      case 2u:
        result = raw_data[(signed __int64)(i + 1)];
        *(&amp;scanf_buffer_bytes + result) -= v3;
        break;
      case 3u:
        result = raw_data[(signed __int64)(i + 1)];
        *(&amp;scanf_buffer_bytes + result) ^= v3;
        break;
      case 4u:
        result = raw_data[(signed __int64)(i + 1)];
        *(&amp;scanf_buffer_bytes + result) *= v3;
        break;
      case 5u:
        result = raw_data[(signed __int64)(i + 1)];
        *(&amp;scanf_buffer_bytes + result) ^= *(&amp;scanf_buffer_bytes + raw_data[(signed __int64)(i + 2)]);
        break;
      default:
        continue;
    }
  }
  return result;
}
</code></pre>

<p>读一下代码，大意是从 <code>raw_data</code> 依次读取数据，3 Bytes 为一组。Byte 1 用来 switch，Byte 2 用来指定相对于 <code>buffer</code> 的偏移量，Byte 3 用以参与计算。</p>

<p>所以代码到这就很明显了，从 <code>goal_dword</code> 逆操作还原出 <code>scanf_buffer_bytes</code> 即可。不过代码里有两个坑：</p>

<ol>
<li>从 <code>goal_dword</code> 取数据时需要每 4 位只保留最低位。</li>
<li>会溢出</li>
</ol>

<pre><code class="language-python">#IDAPython

import sys
raw_data = 0x00000000006010C0
answer   = 0x0000000000601060
buffer   = 0x0000000000604B80

# 逆操作
op = {
    1: lambda x, y: (x-y)%sys.maxint+1 if x-y&lt;0 else x-y,
    # 这里为了模拟溢出，比较粗暴
    2: lambda x, y: (x+y)%maxint,
    3: lambda x, y: x^y,
    4: lambda x, y: x/y,
}

for i in range(24):
    PatchByte(buffer+i, Byte(answer+4*i))

for i in range(14997, -1, -3):
    v0 = Byte(raw_data + i)
    v1 = Byte(raw_data + i + 1)
    v2 = Byte(raw_data + i + 2)
    if v0 &gt; 0 and v0 &lt; 5:
        PatchByte(buffer+v1, op[v0](Byte(buffer+v1), v2))
    elif v0 == 5:
        PatchByte(buffer+v1, Byte(buffer+v1)^Byte(buffer+v2))
        break
    else:
        continue

# find flag at buffer
</code></pre>

<h2 id="maze">maze</h2>

<p>照常拖进 IDA 顺势 F5，读代码：</p>

<pre><code class="language-c">__int64 __fastcall main(__int64 a1, char **a2, char **a3)
{
  signed __int64 offset; // rbx@4
  signed int chr; // eax@5
  bool v5; // bp@5
  bool v6; // al@8
  const char *msg; // rdi@19
  __int64 y; // [sp+0h] [bp-28h]@1
  __int32 x;  // 读汇编后觉得 &amp;y+1 视为 &amp;x 更好

  x = 0L;
  y = 0LL;
  puts(&quot;Input flag:&quot;);
  scanf(&quot;%s&quot;, &amp;buffer, 0LL);
  if ( strlen(&amp;buffer) != 24 || strncmp(&amp;buffer, &quot;nctf{&quot;, 5uLL) || *(&amp;byte_6010BF + 24) != 125 )
  {
  // assert len(buffer) == 24 &amp;&amp; buffer.startswith(&quot;nctf{&quot;) &amp;&amp; buffer.endswith(&quot;}&quot;)
wrong_and_exit:
    puts(&quot;Wrong flag!&quot;);
    exit(-1);
  }

  offset = 5LL;  // 从 { 后面第一个字符开始，后边 ++offset 遍历 buffer

  if ( strlen(&amp;buffer) - 1 &gt; 5 )  // 恒为真
  {
    while ( 1 )
    {
      chr = *(&amp;buffer + offset);
      v5 = 0;
      if ( chr &gt; 'N' )
      {
        chr = (unsigned __int8)chr;
        if ( (unsigned __int8)chr == 'O' )
        {
          v6 = func_O((_DWORD *)&amp;x);  // v6 = x-- &gt; 0;
          goto assign_v6_to_v5_and_goto_label_15;
        }
        if ( chr == 'o' )
        {
          v6 = func_o((int *)&amp;x);  // v6 = x++ &lt; 8;
          goto assign_v6_to_v5_and_goto_label_15;
        }
      }
      else
      {
        chr = (unsigned __int8)chr;
        if ( (unsigned __int8)chr == '.' )
        {
          v6 = func_dot(&amp;y);  // v6 = y-- &gt; 0;
          goto assign_v6_to_v5_and_goto_label_15;
        }
        if ( chr == '0' )
        {
          v6 = func_0((int *)&amp;y);  // v6 = y++ &lt; 8;
assign_v6_to_v5_and_goto_label_15:
          v5 = v6;
          goto LABEL_15;
        }
      }
      // 分析到下边发现是走迷宫，O左 o右 .上 0下
LABEL_15:
      if ( !(unsigned __int8)check(asc_601060, x, y) )  // SHIDWORD(y) == x, 检查是否撞到墙壁
        // asc_601060: 8x8 array
        //   ******
        // *   *  *
        // *** * **
        // **  * **
        // *  *#  *
        // ** *** *
        // **     *
        // ********
        // return 1 if asc[x][y] == (' ' or '#') else 0
        goto wrong_and_exit;  // assert return == 1;
      if ( ++offset &gt;= strlen(&amp;buffer) - 1 )  // 自增，如果下一个已经是 }，则：
      {
        if ( v5 )  // 防止走出迷宫的范围
          break;
wrong_and_exit_2:
        msg = &quot;Wrong flag!&quot;;
        goto show_msg_and_exit;
      }
    }
  }
  if ( *(&amp;asc_601060[8 * (signed int)y] + x) != '#' )  // 最后要以 # 为终点，否则 wrong
    goto wrong_and_exit_2;
  msg = &quot;Congratulations!&quot;;
show_msg_and_exit:
  puts(msg);
  return 0LL;
}
// 综上，就是走迷宫，从 (0, 0) 走到 # 处即为 flag
</code></pre>

<h2 id="wxyvm2">WxyVM2</h2>

<p>丢进 IDA，发现 “Sorry, this node is too big to display”，顿时觉得水深 [一脸黑线]。我不管！读汇编好费时的！F5 之后放一边，居然被我等来了 C 代码，哈哈哈，那就继续分析。</p>

<p>一看发现两万多行，emmm，先读下头尾。很简单，<code>scanf</code> 到 <code>0x694100</code> 处，一番操作后与 <code>0x6940600</code> 进行比对而已（依旧是那个 byte 与 dword 比对的坑，小心）。所以我就去头去尾，把代码丢 Sublime 里分析了。</p>

<p>看了一会，发现了猫腻：</p>

<p><code>scanf</code> 放进去那个 <code>buffer</code> 的范围是 <code>0x694100 ~ 0x694118</code>，最终比对的目标是 <code>0x694060 ~ 0x6940C0</code>，而且后者的数据没变过。又发现中间那两万多行很多跟解题无关，就把对无关地址的操作全剔除了，剩下两千多行有效操作。</p>

<p>然后思路就很清晰了，反向操作即可。先写个 py 脚本逆一下操作顺序：</p>

<pre><code class="language-python">l = [i for i in open('operations.txt')]
f = open('operations-reversed.txt', 'w')
for i in reversed(l):
    f.write(i)
f.close()
# 没有 close() 至少也 flush() 一下…刚开始这里忘了，卡了很久，很奇怪为啥数据少了一小部分…
</code></pre>

<p>然后在 Sublime 里把 <code>--</code> 换成 <code>-= 1</code>，<code>++</code> 同理。再写个很丑的正则替换一下各个操作：<code>(\w+)_(\w+) \+= (.*?);</code> to <code>$1(0x$2) -= $3;</code>，这里是加法变减法，其他同理。</p>

<p>由于看起来很可能会有溢出，我就直接用 C 写了，省得像之前那样活生生地在 py 里模拟溢出…</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;inttypes.h&gt;

uint8_t goal[25] = {
    0xC0, 0x85, 0xF9, 0x6C, 0xE2, 0x14, 0xBB, 0xE4, 0x0D,
    0x59, 0x1C, 0x23, 0x88, 0x6E, 0x9B, 0xCA, 0xBA, 0x5C,
    0x37, 0xFF, 0x48, 0xD8, 0x1F, 0xAB, 0xA5 };

#define byte(i) goal[i-0x694100]

int main() {
    // 这里放上边得到的逆操作们

    for (int i=0; i&lt;25; ++i)
        printf(&quot;%c&quot;, goal[i]);
    return 0;
}
</code></pre>

<hr />

<p>Over，至此南邮的训练平台逆向入门题 All Clear~</p>

<hr />

<p>Here are two useful pages:</p>

<ol>
<li><a href="https://www.cnblogs.com/ljtknowns/p/5741341.html">汇编指令缩写, ljtcnblogs</a></li>
<li><a href="http://blog.csdn.net/huiguixian/article/details/52026710">IDA逆向常用宏定义, 小小攻城师</a></li>
</ol>

</main>


<div id="disqus_thread"></div>
<script type="text/javascript">

(function() {
  
  
  if (window.location.hostname == "localhost")
    return;

  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  var disqus_shortname = 'oyiadin';
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com/" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


  <footer>
  <script src="/js/math-code.js"></script>
<script async src="//mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script>



  
  <hr/>
  &copy; <a href="https://blog.b1n.top/">oyiadin</a> | <a href="https://github.com/oyiadin">Github</a> | <a href="https://twitter.com/oyiadin">Twitter</a>
  
  </footer>
  </body>
</html>

